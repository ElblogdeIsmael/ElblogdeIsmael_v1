<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de Prácticas de Sistemas Concurrentes y Distribuidos - Tema 2 - Exclusión Mutua</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            font-size: 18px;
        }
        h1 {
            text-align: center;
            color: #007bff;
            margin-bottom: 30px;
        }
        .question {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .question:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .question.correct {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .question.incorrect {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        .explanation {
            background: #e7f3fe;
            border: 1px solid #b2d4fe;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        .author {
            margin-top: 20px;
            font-style: italic;
            text-align: center;
        }
        input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        input[type="button"] {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s, transform 0.3s;
        }
        input[type="button"]:hover {
            background-color: #0056b3;
            transform: translateY(-3px);
        }
    </style>
</head>
<body>

    <h1>Test de Prácticas de Sistemas Concurrentes y Distribuidos - Tema 2 - Exclusión Mutua </h1>
    <ul class="author"></ul>
        <li><strong>Autor:</strong> Ismael Sallami Moreno</li>
        <li><strong>Titulación:</strong> Ingeniería Informática y ADE</li>
        <li><strong>Asignatura:</strong> Sistemas Concurrentes y Distribuidos</li>
    </ul>
    <br>
    <div class="question" id="q1">
        <p>¿Qué garantiza el algoritmo de Dijkstra para N procesos?</p>
        <ol type="a">
            <li><label><input type="radio" name="q1" value="0"> Acceso simultáneo a la sección crítica</label></li>
            <li><label><input type="radio" name="q1" value="0"> Eliminación de la necesidad de turnos</label></li>
            <li><label><input type="radio" name="q1" value="0"> Exclusión mutua con tiempo de espera limitado</label></li>
            <li><label><input type="radio" name="q1" value="0"> Uso de variables globales compartidas</label></li>
            <li><label><input type="radio" name="q1" value="1"> Exclusión mutua sin control de inanición</label></li>
        </ol>
    </div>
    <div class="question" id="q2">
        <p>¿Qué propiedad NO es garantizada por el algoritmo de Dijkstra?</p>
        <ol type="a">
            <li><label><input type="radio" name="q2" value="0"> Uso equitativo de los recursos</label></li>
            <li><label><input type="radio" name="q2" value="0"> Alcanzabilidad de la sección crítica</label></li>
            <li><label><input type="radio" name="q2" value="0"> Exclusión mutua</label></li>
            <li><label><input type="radio" name="q2" value="1"> Ausencia de inanición</label></li>
            <li><label><input type="radio" name="q2" value="0"> Seguridad en el acceso a recursos compartidos</label></li>
        </ol>
    </div>
    <div class="question" id="q3">
        <p>¿Qué representa el turno en un algoritmo de exclusión mutua?</p>
        <ol type="a">
            <li><label><input type="radio" name="q3" value="0"> La señal para finalizar el programa</label></li>
            <li><label><input type="radio" name="q3" value="0"> La prioridad fija de un proceso</label></li>
            <li><label><input type="radio" name="q3" value="1"> El permiso para acceder a la sección crítica</label></li>
            <li><label><input type="radio" name="q3" value="0"> La posición en la cola de espera</label></li>
            <li><label><input type="radio" name="q3" value="0"> La cantidad de procesos activos en el sistema</label></li>
        </ol>
    </div>
    <div class="question" id="q4">
        <p>¿Qué asegura el algoritmo de Peterson al pasar entre etapas?</p>
        <ol type="a">
            <li><label><input type="radio" name="q4" value="0"> La etapa más alta siempre está vacía</label></li>
            <li><label><input type="radio" name="q4" value="0"> Los procesos se bloquean indefinidamente</label></li>
            <li><label><input type="radio" name="q4" value="0"> El acceso a la sección crítica se distribuye aleatoriamente</label></li>
            <li><label><input type="radio" name="q4" value="0"> Los procesos siempre progresan de forma equitativa</label></li>
            <li><label><input type="radio" name="q4" value="1"> Un proceso no avanza sólo si no está más adelantado que los demás y es el último en asignar el turno</label></li>
        </ol>
    </div>
    <div class="question" id="q5">
        <p>¿Qué asegura el uso de etapas en el algoritmo de Peterson?</p>
        <ol type="a">
            <li><label><input type="radio" name="q5" value="0"> Interrupción de procesos de bajo nivel</label></li>
            <li><label><input type="radio" name="q5" value="0"> Eliminación de etapas redundantes</label></li>
            <li><label><input type="radio" name="q5" value="0"> Mayor velocidad de procesamiento</label></li>
            <li><label><input type="radio" name="q5" value="0"> Eliminación del uso de tokens</label></li>
            <li><label><input type="radio" name="q5" value="1"> Exclusión mutua y equidad</label></li>
        </ol>
    </div>
    <div class="question" id="q6">
        <p>¿Cuál es una de las condiciones de Dijkstra para la exclusión mutua?</p>
        <ol type="a">
            <li><label><input type="radio" name="q6" value="1"> Un proceso fuera de la sección crítica no debe bloquear a otros procesos</label></li>
            <li><label><input type="radio" name="q6" value="0"> Asignar recursos de manera aleatoria</label></li>
            <li><label><input type="radio" name="q6" value="0"> Usar variables globales como única solución</label></li>
            <li><label><input type="radio" name="q6" value="0"> Los procesos deben ejecutarse secuencialmente</label></li>
            <li><label><input type="radio" name="q6" value="0"> Los procesos pueden detenerse indefinidamente</label></li>
        </ol>
    </div>
    <div class="question" id="q7">
        <p>¿Cómo maneja el algoritmo de Dijkstra las prioridades entre procesos?</p>
        <ol type="a">
            <li><label><input type="radio" name="q7" value="0"> Asignando turnos de manera fija</label></li>
            <li><label><input type="radio" name="q7" value="0"> Permitiendo que los procesos esperen indefinidamente</label></li>
            <li><label><input type="radio" name="q7" value="0"> Usando una cola FIFO</label></li>
            <li><label><input type="radio" name="q7" value="0"> Asignando valores aleatorios a los procesos</label></li>
            <li><label><input type="radio" name="q7" value="1"> Implementando un contador global de turnos</label></li>
        </ol>
    </div>
    <div class="question" id="q8">
        <p>¿Qué propiedad asegura el algoritmo de Peterson?</p>
        <ol type="a">
            <li><label><input type="radio" name="q8" value="0"> Solo funciona con dos procesos</label></li>
            <li><label><input type="radio" name="q8" value="0"> Necesita una red de comunicaciones</label></li>
            <li><label><input type="radio" name="q8" value="1"> Garantiza exclusión mutua y evita inanición</label></li>
            <li><label><input type="radio" name="q8" value="0"> Depende de semáforos externos</label></li>
            <li><label><input type="radio" name="q8" value="0"> Permite acceso prioritario a un proceso</label></li>
        </ol>
    </div>
    <div class="question" id="q9">
        <p>¿Qué significa "progreso finito" en el contexto de Dijkstra?</p>
        <ol type="a">
            <li><label><input type="radio" name="q9" value="0"> La ejecución de un proceso no se interrumpe</label></li>
            <li><label><input type="radio" name="q9" value="0"> Todos los procesos se ejecutan en paralelo</label></li>
            <li><label><input type="radio" name="q9" value="0"> Los procesos avanzan indefinidamente sin detenerse</label></li>
            <li><label><input type="radio" name="q9" value="1"> Los procesos tienen un tiempo finito para entrar a la sección crítica</label></li>
            <li><label><input type="radio" name="q9" value="0"> El acceso a la memoria es constante</label></li>
        </ol>
    </div>
    <div class="question" id="q10">
        <p>¿Qué mejora introduce el algoritmo de Peterson para N procesos?</p>
        <ol type="a">
            <li><label><input type="radio" name="q10" value="0"> Sustituye la necesidad de semáforos por variables clave locales</label></li>
            <li><label><input type="radio" name="q10" value="0"> Requiere menos pasos que el algoritmo de Dekker</label></li>
            <li><label><input type="radio" name="q10" value="0"> Permite acceso simultáneo a la sección crítica</label></li>
            <li><label><input type="radio" name="q10" value="1"> Garantiza exclusión mutua para cualquier cantidad de procesos</label></li>
            <li><label><input type="radio" name="q10" value="0"> Elimina la inanición en sistemas distribuidos</label></li>
        </ol>
    </div>
    <div class="question" id="q11">
        <p>¿Cómo soluciona el algoritmo de Knuth la inanición en exclusión mutua?</p>
        <ol type="a">
            <li><label><input type="radio" name="q11" value="0"> Eliminando los procesos en espera</label></li>
            <li><label><input type="radio" name="q11" value="0"> Permitiendo que todos los procesos avancen simultáneamente</label></li>
            <li><label><input type="radio" name="q11" value="1"> Garantizando que el tiempo de espera sea limitado para cada proceso</label></li>
            <li><label><input type="radio" name="q11" value="0"> Bloqueando procesos con menor prioridad</label></li>
            <li><label><input type="radio" name="q11" value="0"> Usando turnos circulares para la asignación de recursos</label></li>
        </ol>
    </div>
    <div class="question" id="q12">
        <p>¿Qué hace un proceso después de usar la sección crítica en el algoritmo de Peterson?</p>
        <ol type="a">
            <li><label><input type="radio" name="q12" value="0"> Solicita nuevamente el turno</label></li>
            <li><label><input type="radio" name="q12" value="0"> Envía mensajes a otros procesos</label></li>
            <li><label><input type="radio" name="q12" value="1"> Libera su bandera de "solicitado"</label></li>
            <li><label><input type="radio" name="q12" value="0"> Bloquea a los otros procesos</label></li>
            <li><label><input type="radio" name="q12" value="0"> Incrementa un contador global</label></li>
        </ol>
    </div>
    <div class="question" id="q13">
        <p>¿Qué ocurre si dos procesos intentan acceder simultáneamente en el algoritmo de Peterson?</p>
        <ol type="a">
            <li><label><input type="radio" name="q13" value="0"> Se produce un interbloqueo</label></li>
            <li><label><input type="radio" name="q13" value="1"> Se respetan las reglas de exclusión mutua</label></li>
            <li><label><input type="radio" name="q13" value="0"> Ambos procesos fallan</label></li>
            <li><label><input type="radio" name="q13" value="0"> Ambos entran a la sección crítica</label></li>
            <li><label><input type="radio" name="q13" value="0"> Uno de ellos puede quedar bloqueado indefinidamente</label></li>
        </ol>
    </div>
    <div class="question" id="q14">
        <p>¿Qué técnica introduce el algoritmo de Knuth?</p>
        <ol type="a">
            <li><label><input type="radio" name="q14" value="0"> Uso de prioridad fija entre procesos</label></li>
            <li><label><input type="radio" name="q14" value="0"> Uso de semáforos para exclusión mutua</label></li>
            <li><label><input type="radio" name="q14" value="0"> Solución parcial para sistemas distribuidos</label></li>
            <li><label><input type="radio" name="q14" value="1"> Retraso limitado en el acceso a la sección crítica</label></li>
            <li><label><input type="radio" name="q14" value="0"> Inanición de procesos</label></li>
        </ol>
    </div>
    <div class="question" id="q15">
        <p>¿Cómo resuelve el método de refinamiento sucesivo el problema de exclusión mutua?</p>
        <ol type="a">
            <li><label><input type="radio" name="q15" value="0"> Eliminando el uso de turnos</label></li>
            <li><label><input type="radio" name="q15" value="0"> Permitiendo que dos procesos entren simultáneamente</label></li>
            <li><label><input type="radio" name="q15" value="0"> Usando semáforos binarios</label></li>
            <li><label><input type="radio" name="q15" value="1"> Implementando bucles de espera activa para decidir el acceso</label></li>
            <li><label><input type="radio" name="q15" value="0"> Dividiendo el problema en múltiples secciones críticas</label></li>
        </ol>
    </div>
    <div class="question" id="q16">
        <p>¿Qué es una "etapa" en el algoritmo de Peterson para N procesos? </p>
        <ol type="a">
            <li><label><input type="radio" name="q16" value="0"> Un mecanismo de exclusión global</label></li>
            <li><label><input type="radio" name="q16" value="0"> Un nivel de prioridad fijo para los procesos</label></li>
            <li><label><input type="radio" name="q16" value="0"> Un bucle infinito en la ejecución</label></li>
            <li><label><input type="radio" name="q16" value="1"> Una fase de sincronización antes de la sección crítica</label></li>
            <li><label><input type="radio" name="q16" value="0"> Una señal de error en el sistema</label></li>
        </ol>
    </div>
    <div class="question" id="q17">
        <p>¿Qué condición debe cumplirse para que un proceso entre a la sección crítica en el algoritmo de Peterson? </p>
        <ol type="a">
            <li><label><input type="radio" name="q17" value="1"> Su turno no debe coincidir o la clave del otro proceso debe ser falsa</label></li>
            <li><label><input type="radio" name="q17" value="0"> Su contador debe superar al de los demás procesos</label></li>
            <li><label><input type="radio" name="q17" value="0"> Su clave de solicitud debe ser verdadera</label></li>
            <li><label><input type="radio" name="q17" value="0"> Su prioridad debe ser la más alta</label></li>
            <li><label><input type="radio" name="q17" value="0"> Su solicitud debe ser la primera en la cola</label></li>
        </ol>
    </div>
    <div class="question" id="q18">
        <p>¿Qué problema puede surgir al verificar las claves en algoritmos de refinamiento sucesivo?</p>
        <ol type="a">
            <li><label><input type="radio" name="q18" value="0"> Los turnos se asignan de manera inconsistente</label></li>
            <li><label><input type="radio" name="q18" value="1"> No se realiza la salida de la espera activa de forma atómica</label></li>
            <li><label><input type="radio" name="q18" value="0"> Se producen interrupciones aleatorias</label></li>
            <li><label><input type="radio" name="q18" value="0"> Bloqueo mutuo al intercambiar turnos</label></li>
            <li><label><input type="radio" name="q18" value="0"> Los procesos entran en la sección crítica sin permiso</label></li>
        </ol>
    </div>
    <div class="question" id="q19">
        <p>¿Qué problema intenta resolver la exclusión mutua?</p>
        <ol type="a">
            <li><label><input type="radio" name="q19" value="0"> Bloquear indefinidamente todos los procesos</label></li>
            <li><label><input type="radio" name="q19" value="0"> Evitar el uso de recursos por parte de un proceso</label></li>
            <li><label><input type="radio" name="q19" value="0"> Permitir que todos los procesos accedan a la sección crítica simultáneamente</label></li>
            <li><label><input type="radio" name="q19" value="0"> Acelerar el acceso de los procesos a la memoria compartida</label></li>
            <li><label><input type="radio" name="q19" value="1"> Evitar el acceso simultáneo de múltiples procesos a una sección crítica</label></li>
        </ol>
    </div>
    <div class="question" id="q20">
        <p>¿Qué ocurre si todos los procesos solicitan acceso simultáneamente en el algoritmo de Dijkstra?</p>
        <ol type="a">
            <li><label><input type="radio" name="q20" value="0"> Los procesos se ordenan en cola de prioridad</label></li>
            <li><label><input type="radio" name="q20" value="0"> Se produce un interbloqueo</label></li>
            <li><label><input type="radio" name="q20" value="1"> Uno de ellos accede según el turno asignado</label></li>
            <li><label><input type="radio" name="q20" value="0"> El sistema queda bloqueado indefinidamente</label></li>
            <li><label><input type="radio" name="q20" value="0"> Todos acceden simultáneamente</label></li>
        </ol>
    </div>
    <div class="question" id="q21">
        <p>¿Qué condición garantiza el algoritmo de Knuth?</p>
        <ol type="a">
            <li><label><input type="radio" name="q21" value="0"> Reducción del tiempo de espera a 0</label></li>
            <li><label><input type="radio" name="q21" value="0"> Eliminación de procesos en espera</label></li>
            <li><label><input type="radio" name="q21" value="0"> Inanición de procesos</label></li>
            <li><label><input type="radio" name="q21" value="0"> Interbloqueo constante</label></li>
            <li><label><input type="radio" name="q21" value="1"> Exclusión mutua</label></li>
        </ol>
    </div>
    <div class="question" id="q22">
        <p>¿Qué garantiza el algoritmo de Dekker?</p>
        <ol type="a">
            <li><label><input type="radio" name="q22" value="0"> Equidad completa entre procesos</label></li>
            <li><label><input type="radio" name="q22" value="0"> Inanición de todos los procesos</label></li>
            <li><label><input type="radio" name="q22" value="0"> Una solución distribuida</label></li>
            <li><label><input type="radio" name="q22" value="0"> Ejecución simultánea en la sección crítica</label></li>
            <li><label><input type="radio" name="q22" value="1"> Exclusión mutua, pero puede causar inanición</label></li>
        </ol>
    </div>
    <div class="question" id="q23">
        <p>¿Qué garantiza la propiedad de equidad en exclusión mutua?</p>
        <ol type="a">
            <li><label><input type="radio" name="q23" value="0"> Todos los procesos son bloqueados simultáneamente</label></li>
            <li><label><input type="radio" name="q23" value="0"> Todos los procesos avanzan al mismo tiempo</label></li>
            <li><label><input type="radio" name="q23" value="0"> Solo un proceso ejecuta indefinidamente</label></li>
            <li><label><input type="radio" name="q23" value="1"> Los procesos acceden en orden sin preferencia indebida</label></li>
            <li><label><input type="radio" name="q23" value="0"> No hay necesidad de sincronización</label></li>
        </ol>
    </div>
    <div class="question" id="q24">
        <p>¿Qué asegura la verificación de exclusión mutua en un algoritmo para N procesos?</p>
        <ol type="a">
            <li><label><input type="radio" name="q24" value="0"> Bloquear indefinidamente los procesos que esperan</label></li>
            <li><label><input type="radio" name="q24" value="1"> Garantizar que solo un proceso entre en la sección crítica a la vez</label></li>
            <li><label><input type="radio" name="q24" value="0"> Asignar recursos de manera aleatoria</label></li>
            <li><label><input type="radio" name="q24" value="0"> Permitir acceso simultáneo a múltiples procesos</label></li>
            <li><label><input type="radio" name="q24" value="0"> Prohibir la entrada de todos los procesos</label></li>
        </ol>
    </div>
    <div class="question" id="q25">
        <p>¿Cuál es el principal problema de los bucles de espera activa?</p>
        <ol type="a">
            <li><label><input type="radio" name="q25" value="0"> Reducen el tiempo de espera de los procesos</label></li>
            <li><label><input type="radio" name="q25" value="0"> Facilitan la exclusión mutua</label></li>
            <li><label><input type="radio" name="q25" value="1"> Pueden generar uso innecesario de recursos</label></li>
            <li><label><input type="radio" name="q25" value="0"> Eliminan la necesidad de sincronización</label></li>
            <li><label><input type="radio" name="q25" value="0"> Incrementan la equidad del sistema</label></li>
        </ol>
    </div>

    
















    <!-- Añadir las preguntas adicionales de la misma manera -->

    <input type="button" value="¿Aprobarás?" onclick="checkAnswers()">
</form>

<div class="author">
    <p>Autor: Ismael Sallami Moreno</p>
</div>

<div id="results" style="margin-top: 20px;"></div>

<script>
    function checkAnswers() {
        let score = 0;
        const totalQuestions = 25;
        const resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML = ""; // Limpiar resultados anteriores

        // Respuestas correctas
        const answers = {
            q1: { answer: "1", explanation: " Exclusión mutua sin control de inanición." },
            q2: { answer: "1", explanation: "El algoritmo de Dijkstra no garantiza la ausencia de inanición." },
            q3: { answer: "1", explanation: "El permiso para acceder a la sección crítica." },
            q4: { answer: "1", explanation: "El algoritmo de Peterson asegura que un proceso no avanza solo si no está más adelantado que los demás y es el último en asignar el turno." },
            q5: { answer: "1", explanation: "El uso de etapas en el algoritmo de Peterson asegura la exclusión mutua y equidad." },
            q6: { answer: "1", explanation: "Una de las condiciones de Dijkstra para la exclusión mutua es que un proceso fuera de la sección crítica no debe bloquear a otros procesos." },
            q7: { answer: "1", explanation: "El algoritmo de Dijkstra maneja las prioridades entre procesos implementando un contador global de turnos." },
            q8: { answer: "1", explanation: "El algoritmo de Peterson garantiza exclusión mutua y evita inanición." },
            q9: { answer: "1", explanation: "Progreso finito significa que los procesos tienen un tiempo finito para entrar a la sección crítica." },
            q10: { answer: "1", explanation: "El algoritmo de Peterson para N procesos garantiza exclusión mutua para cualquier cantidad de procesos." },
            q11: { answer: "1", explanation: "El algoritmo de Knuth soluciona la inanición garantizando que el tiempo de espera sea limitado para cada proceso y usando turnos circulares para la asignación de recursos." },
            q12: { answer: "1", explanation: "Después de usar la sección crítica, un proceso en el algoritmo de Peterson libera su bandera de 'solicitado'." },
            q13: { answer: "1", explanation: "Si dos procesos intentan acceder simultáneamente en el algoritmo de Peterson, se respetan las reglas de exclusión mutua." },
            q14: { answer: "1", explanation: "El algoritmo de Knuth introduce la técnica de retraso limitado en el acceso a la sección crítica." },
            q15: { answer: "1", explanation: "El método de refinamiento sucesivo resuelve el problema de exclusión mutua implementando bucles de espera activa para decidir el acceso." },
            q16: { answer: "1", explanation: "Una 'etapa' en el algoritmo de Peterson para N procesos es un nivel de prioridad fijo para los procesos y una fase de sincronización antes de la sección crítica." },
            q17: { answer: "1", explanation: "Para que un proceso entre a la sección crítica en el algoritmo de Peterson, su turno no debe coincidir o la clave del otro proceso debe ser falsa." },
            q18: { answer: "1", explanation: "No se realiza la salida de la espera activa de forma atómica." },
            q19: { answer: "1", explanation: "La exclusión mutua intenta evitar el acceso simultáneo de múltiples procesos a una sección crítica." },
            q20: { answer: "1", explanation: "Si todos los procesos solicitan acceso simultáneamente en el algoritmo de Dijkstra, uno de ellos accede según el turno asignado." },
            q21: { answer: "1", explanation: "El algoritmo de Knuth garantiza la exclusión mutua." },
            q22: { answer: "1", explanation: "El algoritmo de Dekker garantiza la exclusión mutua, pero puede causar inanición." },
            q23: { answer: "1", explanation: "La propiedad de equidad en exclusión mutua garantiza que los procesos acceden en orden sin preferencia indebida." },
            q24: { answer: "1", explanation: "La verificación de exclusión mutua en un algoritmo para N procesos garantiza que solo un proceso entre en la sección crítica a la vez." },
            q25: { answer: "1", explanation: "El principal problema de los bucles de espera activa es que pueden generar uso innecesario de recursos." }
        };

        for (let i = 1; i <= totalQuestions; i++) {
            const question = document.querySelectorAll(`input[name="q${i}"]:checked`);
            if (question.length > 0) {
            const selectedValues = Array.from(question).map(q => q.value);
            const correctAnswers = Array.isArray(answers[`q${i}`].answer) ? answers[`q${i}`].answer : [answers[`q${i}`].answer];
            const isCorrect = selectedValues.length === correctAnswers.length && selectedValues.every(val => correctAnswers.includes(val));
            
            if (isCorrect) {
                score++;
                document.getElementById(`q${i}`).classList.add('correct');
            } else {
                document.getElementById(`q${i}`).classList.add('incorrect');
                // Mostrar solo la justificación
                const explanation = answers[`q${i}`].explanation;
                const explanationDiv = document.createElement("div");
                explanationDiv.className = "explanation";
                explanationDiv.innerHTML = `<strong>Justificación:</strong> ${explanation}`;
                document.getElementById(`q${i}`).appendChild(explanationDiv);
            }
            }
        }

        // Cálculo de la nota sobre 10
        const grade = (score / totalQuestions) * 10;
        resultsDiv.innerHTML = `<h3>Tu puntuación es ${grade.toFixed(1)} sobre 10</h3>`;
        alert(`Tu puntuación es ${score} de ${totalQuestions}`);
    }
</script>

</body>
</html>
